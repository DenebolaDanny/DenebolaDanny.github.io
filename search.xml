<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[3 : 软件测试标准]]></title>
      <url>http://yoursite.com/2016/06/19/Software-Testing-Standards/</url>
      <content type="html"><![CDATA[<h2 id="软件的生命周期及开发模型"><a href="#软件的生命周期及开发模型" class="headerlink" title="软件的生命周期及开发模型"></a>软件的生命周期及开发模型</h2><p><img src="http://i.imgur.com/Fskd7S0.jpg" alt=""></p>
<p><strong>开发模型</strong>：</p>
<p>瀑布、螺旋、原型、增量、敏捷、Rational统一过程</p>
<p>##测试模型</p>
<p>V、W、H</p>
<h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p>V模型是软件开发瀑布模型的变种，它反映了测试活动与分析设计的关系。</p>
<p><img src="http://i.imgur.com/DTR8op6.jpg" alt=""></p>
<ul>
<li><p>需求、功能、设计和编码的开发活动随时间而进行，而相应的测试活动（即针对需求、功能、设计和编码的测试）开展的次序正好相反。</p>
</li>
<li><p>成功应用V模型的关键因素是设计测试案例的时机。</p>
</li>
</ul>
<p><strong>局限</strong>：</p>
<p>主要是针对程序进行测试寻找错误，而需求分析阶段隐藏的问题一直到后期的验收测试才被发现。</p>
<h3 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h3><p><img src="http://i.imgur.com/eb0JYwV.jpg" alt=""></p>
<p>测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、功能和设计同样要测试。只要相应的开发活动完成，就可以开始执行测试（例如，需求分析一完成，我们就可以对需求进行测试，而不是到最后才进行针对需求的验收测试）。测试与开发是同步进行的。</p>
<p><strong>局限</strong>：</p>
<p>W模型和V模型都把软件的开发视为需求、设计、编码等一系列串行的活。同样的，软件开发和测试保持一种线性的前后关系，需要有严格的指令表示上一阶段完全结束，才可正式开始下一阶段。这样就无法支持迭代、自发性以及变更调整。对于当前很多文档需要事后补充，或者根本没有文档的做法下（这已成为一种开发的文化），开发人员和测试人员都面临同样的困惑。</p>
<h3 id="H模型"><a href="#H模型" class="headerlink" title="H模型"></a>H模型</h3><p>H模型将测试活动完全独立出来，形成一个独立的流程，将测试准备活动和测试执行活动清晰地体现出来。</p>
<p><img src="http://i.imgur.com/bMEY1qo.jpg" alt=""></p>
<ul>
<li><p>测试准备活动：需求分析、测试计划、测试分析、测试编码、测试验证</p>
</li>
<li><p>测试执行活动：测试运行、测试报告、测试分析</p>
</li>
</ul>
<h3 id="测试模型的使用"><a href="#测试模型的使用" class="headerlink" title="测试模型的使用"></a>测试模型的使用</h3><p>在实际的工作中，我们要灵活地运用各种模型的优点，在W模型的框架下，运用H模型的思想进行独立地测试，并同时将测试和开发紧密结合，寻找恰当的就绪点开始测试并反复迭代测试，最终保证按期完成预定目标。</p>
<p><strong>α测试</strong>：Alpha测试是由选定的用户进行的产品早期性测试，这个测试一般在可控的环境下进行。<br><strong>β测试</strong>：Beta测试是从用户角度进行的测试，是由软件的多个用户在一个或多个用户的实际使用环境下进行的测试。它是在开发者无法控制的软件环境下进行的软件现场应用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2 : 软件测试实践]]></title>
      <url>http://yoursite.com/2016/06/19/Software-Testing-Practice/</url>
      <content type="html"><![CDATA[<h2 id="测试团队"><a href="#测试团队" class="headerlink" title="测试团队"></a>测试团队</h2><p><strong>三种组织模型</strong>：</p>
<ol>
<li>以开发为核心：</li>
</ol>
<p><img src="http://i.imgur.com/G94tS9M.jpg" alt=""></p>
<ol>
<li>以项目经理为核心：</li>
</ol>
<p><img src="http://i.imgur.com/ykqV47W.jpg" alt=""></p>
<ol>
<li>三国鼎立：</li>
</ol>
<p><img src="http://i.imgur.com/enBQHAg.jpg" alt=""></p>
<p><strong>测试团队规模</strong></p>
<ul>
<li><p>操作系统：测试人员与开发人员为2:1</p>
</li>
<li><p>应用平台、支撑系统：测试人员和开发人员的比例一般在1:1左右</p>
</li>
<li><p>特定应用类产品：测试人员与开发人员的比例一般在1:2~1:4</p>
</li>
</ul>
<hr>
<h2 id="需求分析与测试计划"><a href="#需求分析与测试计划" class="headerlink" title="需求分析与测试计划"></a>需求分析与测试计划</h2><p><strong>软件需求的层次</strong>：</p>
<ul>
<li><p>业务需求反映组织机构或客户对系统、产品的概括性要求，包括所要达到的业务目标，有项目视图与范围文档说明</p>
</li>
<li><p>用户角色需求描述用户使用系统而要完成的各种任务，有用例（use case）文档或方案脚本说明</p>
</li>
<li><p>功能需求定义开发人员必须实现的软件功能，它源于用户需求，是软件需求说明书中重要的组成部分</p>
</li>
</ul>
<h2 id="设计和维护测试用例"><a href="#设计和维护测试用例" class="headerlink" title="设计和维护测试用例"></a>设计和维护测试用例</h2><p><strong>测试用例定义</strong>：</p>
<p>测试用例是可以独立进行测试执行的最小单元</p>
<p><strong>书写标准</strong>：</p>
<p>标识符、测试项、测试环境要求、输入标准、输出标准、测试用例之间的关联</p>
<p><strong>质量要求</strong>：</p>
<p>覆盖率、易用性、易维护性、粒度适中</p>
<h2 id="部署测试环境"><a href="#部署测试环境" class="headerlink" title="部署测试环境"></a>部署测试环境</h2><p><strong>虚拟机的作用</strong></p>
<ul>
<li><p>充分利用硬件资源</p>
</li>
<li><p>节约能源和空间</p>
</li>
<li><p>提升运作效率</p>
</li>
<li><p>有利于环境的建立和维护</p>
</li>
</ul>
<h2 id="报告软件缺陷"><a href="#报告软件缺陷" class="headerlink" title="报告软件缺陷"></a>报告软件缺陷</h2><h3 id="缺陷的生命周期"><a href="#缺陷的生命周期" class="headerlink" title="缺陷的生命周期"></a>缺陷的生命周期</h3><ul>
<li><p>软件缺陷生命周期指的是从一个软件缺陷被发现、报告到这个缺陷被修复、验证直至最后关闭的完整过程。</p>
</li>
<li><p>缺陷生命周期是各类开发人员一起参与、协同测试的过程。</p>
</li>
</ul>
<p><img src="http://i.imgur.com/eymeWux.jpg" alt=""></p>
<h3 id="严重性及优先级"><a href="#严重性及优先级" class="headerlink" title="严重性及优先级"></a>严重性及优先级</h3><p><strong>严重性</strong>：</p>
<p>致命的（fatal）、严重的（critical）、一般的（major）、微小的（minor）</p>
<p><strong>优先级</strong>：</p>
<p><img src="http://i.imgur.com/ulDwZd6.jpg" alt=""></p>
<p><strong>缺陷报告内容</strong></p>
<ul>
<li><p>“步骤”提供了如何重复当前缺陷的准确描述，应简明而完备、清楚而准确。这些信息对开发人员是关键的，视为修复缺陷的向导。</p>
</li>
<li><p>“期望结果”与测试用例标准或设计规格说明书或用户需求等一致，达到软件预期的功能。是验证缺陷的依据。</p>
</li>
<li><p>“实际结果”实际执行测试的结果，不同于期望结果，从而确认缺陷的存在。</p>
</li>
</ul>
<p><strong>缺陷报告要求</strong></p>
<p>单一准确、可以再现、完整统一、短小简练、特定条件、补充完善、不做评价</p>
<h2 id="测试评估"><a href="#测试评估" class="headerlink" title="测试评估"></a>测试评估</h2><p><strong>目的</strong>：</p>
<ul>
<li><p>量化测试进程，判断测试进行的状态和进度</p>
</li>
<li><p>为测试或质量分析报告生成所需的量化数据，如缺陷清除率、测试覆盖率等</p>
</li>
</ul>
<p><strong>种子公式</strong>：</p>
<p><img src="http://i.imgur.com/4VeEXZC.jpg" alt=""></p>
<p>推出程序的总Bug数为 N = S * n /s</p>
<p>其中n是所进行实际测试时发现的Bug总数。如果n= N，说明所有的Bug已找出来，说明做的测试足够充分</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[1 : 软件测试基础]]></title>
      <url>http://yoursite.com/2016/06/19/Software-Testing-Foundation/</url>
      <content type="html"><![CDATA[<h2 id="测试支持度模型-TSM"><a href="#测试支持度模型-TSM" class="headerlink" title="测试支持度模型 TSM"></a>测试支持度模型 TSM</h2><p>TSM有3个级别</p>
<ul>
<li>第一级：弱（weak）。可测性支持，很少测试问题被提及。</li>
<li>第二级：基本（basic）。可测性支持，基本的测试问题被提及。</li>
<li>第三级：强（strong）。可测性支持，所有测试问题被提及。</li>
</ul>
<p>测试成熟度模型（TMM）</p>
<ul>
<li><p>第一级：初始级（Initial）<br>没有定义成熟度目标（Maturity Goal）</p>
</li>
<li><p>第二级：阶段定义级（Phase Definition）<br>目标1：进行测试和调试的目标<br>目标2：开始一个测试计划过程</p>
</li>
<li><p>第三级：集成级（Integration）<br>目标1：建立一个软件测试组织<br>目标2：测试集成进入软件生命周期<br>目标3：控制和监测测试过程</p>
</li>
<li><p>第四级：管理和度量级（Management and Measurement）<br>目标1：建立一个面向组织的评价程序<br>目标2：建立一个技术培训程序<br>目标3：建立一个测试度量程序<br>目标4：软件质量评价</p>
</li>
<li><p>第五级：优化/缺陷预防和质量控制（Optimization/Defect Prevention andQuality Control）<br>目标1：应用缺陷预防数据过程<br>目标2：质量控制</p>
</li>
</ul>
<h2 id="软件测试的定义"><a href="#软件测试的定义" class="headerlink" title="软件测试的定义"></a>软件测试的定义</h2><p>在特定的条件下运行系统或构件，观察或记录结果，对系统的某个方面做出评价。</p>
<p>分析某个软件项以发现现存的和要求的条件之差别（即错误）并评价此软件项的特性。</p>
<h2 id="软件质量定义"><a href="#软件质量定义" class="headerlink" title="软件质量定义"></a>软件质量定义</h2><p>系统、部件或过程满足顾客或用户需求或期望的程度。</p>
<h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><p><strong>定义</strong></p>
<ol>
<li><p>软件未达到产品说明书标明的功能</p>
</li>
<li><p>软件出现了产品说明书指明不会出现的错误</p>
</li>
<li><p>软件功能超出产品说明书指明范围</p>
</li>
<li><p>软件未达到产品说明书虽未指出但应达到的目标</p>
</li>
<li><p>软件测试人员认为软件难以理解、不易使用、运行速度慢，或者最终用户认为不好</p>
</li>
</ol>
<p>缺陷时对软件产品预期属性的偏离现象</p>
<p><strong>缺陷产生的原因</strong>：</p>
<p>技术问题：</p>
<ul>
<li>算法错误，语法错误，计算和精度问题，接口参数传递不匹配</li>
<li>没有考虑系统的自我恢复或数据的异地备份、灾难性恢复等问题</li>
</ul>
<p>团队工作：</p>
<ul>
<li>误解、沟通不充分</li>
</ul>
<p>软件本身：</p>
<ul>
<li>文档错误、用户使用场合（user scenario）</li>
<li>时间上不协调、或不一致性所带来的问题</li>
</ul>
<p>规格说明书的缺陷会在需求分析审查、设计、编码、测试等过程中会逐步发现，而不能在需求分析一个阶段发现。</p>
<h2 id="测试的分类"><a href="#测试的分类" class="headerlink" title="测试的分类"></a>测试的分类</h2><ul>
<li>按测试的阶段或层次分类，如单元测试、集成、系统测试等。</li>
<li>按测试目的分类，如功能测试、性能测试、可靠性测试、安全性测试和兼容性测试等。</li>
<li>根据测试过程中被测软件是否被执行，分为静态测试和动态测试。</li>
<li>根据是否针对系统的内部结构和具体实现算法来完成测试，可分为白盒测试和黑盒测试。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[6 : 软件测试自动化]]></title>
      <url>http://yoursite.com/2016/06/19/Software-Test-Automation/</url>
      <content type="html"><![CDATA[<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>自动化测试（automated test）是相对手工测试而存在的一个概念，由手工逐个地运行测试用例的操作过程被测试工具自动执行的过程所代替。</p>
<p>测试工具的使用是自动化测试的主要特征。</p>
<p>在系统功能逻辑测试、验收测试、适用性测试、涉及物理交互性测试时，多采用黑盒测试的手工测试方法。</p>
<p>单元测试、集成测试、系统负载或性能、稳定性、可靠性测试等比较适合采用TA。</p>
<p>代码分析是一种白盒测试的自动化方法。</p>
<p>捕获和回放是一种黑盒测试的自动化方法</p>
<h2 id="测试工具的分类"><a href="#测试工具的分类" class="headerlink" title="测试工具的分类"></a>测试工具的分类</h2><ul>
<li>根据测试方法不同，分为白盒测试工具和黑盒测试工具、静态测试工具和动态测试工具等。</li>
<li>根据工具的来源不同，分为开源测试工具（多数是免费的）和商业测试工具、自主开发的测试工具和第三方测试工具等。</li>
<li>根据测试的对象和目的，分为单元测试工具、功能测试工具、性能测试工具、测试管理工具等。</li>
</ul>
<h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><p>测试人员要坚持原则，缺陷未修复完坚决不予通过。（X）</p>
<p>实施缺陷跟踪的目的是：软件质量无法控制、问题无法量化、重复问题接连产生、解决问题的知识无法保留 </p>
<pre><code>以下选项中不属于ISO软件质量模型的是        C。 

A）外部质量模型 B）使用质量模型C）维护质量模型 D）内部质量模型 
</code></pre><blockquote>
<p>坚持在软件开发的各个阶段实施下列哪种质量保证措施，才能在开发过程中尽早发现和预防错误，把出现的错误克服在早期  A </p>
<p>A）技术评审         B）程序测试         C）文档审查         D）管理评审</p>
</blockquote>
<pre><code>在软件性能测试中，下列指标中哪个不是软件性能的指标（D）

 A响应时间 B吞吐量 C资源利用率 D并发进程数
</code></pre><blockquote>
<p>下列关于软件可靠性测试的说法中，错误的是（A）</p>
<p> A发现软件缺陷是软件可靠性测试的主要目的 </p>
<p>B软件可靠性测试通常用于有可靠性要求的软件 </p>
<p>C在一次软件可靠性测试中，执行的测试用例必须完全符合所有定义的软件运行剖面</p>
<p> D可靠性测试通常要对测试结果进行分析才能获得测试结论 </p>
</blockquote>
<pre><code>实际的逻辑覆盖测试中，一般以（C  ）为主设计测试用例。 

A. 条件覆盖 B. 判定覆盖 C. 条件组合覆盖 D. 路径覆盖
</code></pre><blockquote>
<p>单元测试主要由（ C ）完成？其中（ A ）起主要作用。 </p>
<p>A． 开发人员 B． 测试人员 C． 开发人员和测试人员 D． 以上都不对</p>
</blockquote>
<pre><code>单元测试是以详细设计说明书为指导

集成测试是以概要设计说明书为指导

确认测试是以需求分析说明书为指导
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[5 : 测试应用技术]]></title>
      <url>http://yoursite.com/2016/06/19/test-design/</url>
      <content type="html"><![CDATA[<h2 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h2><p>兼容性测试验证软件与其所依赖的环境的依赖程度，包括对硬件的依赖程度，对平台软件、其他软件的依赖程度等。</p>
<p>是软件测试中投入较大的一部分。</p>
<p><strong>目的</strong>：确认硬件环境的描述是否正确</p>
<p>对于定制系统来说，兼容性测试应尽早进行，否则系统投入使用后，随着系统中数据的增多，兼容性测试的风险和投入将越来越大。</p>
<h2 id="易用性测试"><a href="#易用性测试" class="headerlink" title="易用性测试"></a>易用性测试</h2><p>易用性是指软件产品被理解、学习、使用和吸引用户的能力。</p>
<p>易用性是一个很广泛的概念，它涉及到易理解性、易学习性、美观性、一致性、业务符合性等方面。</p>
<h2 id="可靠性测试"><a href="#可靠性测试" class="headerlink" title="可靠性测试"></a>可靠性测试</h2><ul>
<li>执行时间（Executing Time）是指执行一个程序所用的实际时间和中央处理器所用的时间，或者是程序处于执行过程中的一段时间</li>
<li>日历时间（Calendar Time）指的是编年时间，包括计算机可能未运行的时间</li>
<li>时钟时间（Clock Time）是指从程序执行开始到程序执行完毕所经历的钟表时间</li>
</ul>
<h2 id="负载压力测试"><a href="#负载压力测试" class="headerlink" title="负载压力测试"></a>负载压力测试</h2><p>系统的负载压力是指系统在某种指定软件、硬件以及网络环境下承受的流量，例如并发用户数、持续运行时间、数据量等，其中<strong>并发用户数是负载压力的重要体现。</strong></p>
<p><strong>负载测试</strong>是确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统组成部分的相应输出项，例如通过量、响应时间、CPU负载、内存使用等如何决定系统的性能，如稳定性和响应等。</p>
<p><strong>负载压力测试</strong>是指在一定的约束条件下测试系统所能承受的并发用户数量、运行时间、数据量，以确定系统所能承受的最大负载压力。</p>
<p>负载压力测试包括：</p>
<ul>
<li>并发性能测试（重点）</li>
<li>疲劳强度测试</li>
<li>大数据量测试</li>
</ul>
<h2 id="测试环境、工具、数据准备"><a href="#测试环境、工具、数据准备" class="headerlink" title="测试环境、工具、数据准备"></a>测试环境、工具、数据准备</h2><p>缺陷：</p>
<ul>
<li>缺乏功能点的校验</li>
<li>对有些控件支持得不好</li>
<li>不能达到真实模拟负载</li>
<li>脚本的支持不够灵活</li>
<li>报错定位不够详细</li>
</ul>
<p>盲点：</p>
<ul>
<li>当功能错误发生时，测试工具不能够记录产生的功能性错误，这就忽略了负载压力情况下的功能不稳定问题。</li>
<li>记录所有虚拟用户的操作及服务器的响应是当前负载压力测试技术发展的最大挑战。</li>
<li>导致资源消耗、操作行为增加以及产生大量日志等问题。</li>
</ul>
<h2 id="本地化与国际化"><a href="#本地化与国际化" class="headerlink" title="本地化与国际化"></a>本地化与国际化</h2><p>软件国际化：I18N<br>软件本地化：L10N<br>软件全球化：G11N</p>
<p>I18N是L10N的基础和前提，为L10N做准备</p>
<p>I18N是软件产品源语言开发的一部分，属于Engineering</p>
<p><img src="http://i.imgur.com/y1TLVuZ.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[4 : 测试设计技术]]></title>
      <url>http://yoursite.com/2016/06/16/test-design/</url>
      <content type="html"><![CDATA[<h1 id="测试设计技术"><a href="#测试设计技术" class="headerlink" title="测试设计技术"></a>测试设计技术</h1><p>测试对象不仅仅是源代码，还包括需求分析、需求规格说明书、概要设计、概要设计说明书、详细设计、详细设计说明书、使用手册等各阶段的文档。</p>
<hr>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><ul>
<li><p>测试用例是为了特定目的而设计的测试数据及与之相关的测试规程的一个特定的集合， 称为有效地发现软件缺陷的<strong>最小测试执行单元</strong>。</p>
</li>
<li><p>软件质量的好坏很大程度上取决于测试用例的数量和质量</p>
</li>
</ul>
<blockquote>
<ul>
<li>测试用例是测试人员执行测试的重要参考依据。</li>
<li>良好的测试用例具有复用的功能，在测试过程中可以重复使用。</li>
<li>测试用例是在长期测试实践中积累起来的</li>
<li>测试用例也是检验测试人员进度、工作量以及跟踪/管理测试人员的工作效率的因素</li>
<li>对于单元测试来说，软件规模与测试用例数基<br>本上是成比例的<br>对于集成测试和系统测试，测试用例数与软件<br>规模不是简单的正比关系，软件规模越大，模<br>块间关系越复杂</li>
</ul>
</blockquote>
<h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><p>确定输入和输出参数：边界值分析-&gt;等价类划分-&gt;错误推测-&gt;检查逻辑覆盖</p>
<p>如果程序的功能说明中含有输入条件的组合情况，则一开始就可以选择因果图法。</p>
<p>书写规范：标识符，测试项，测试环境要求，输入，预期输出</p>
<hr>
<h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p><strong>概念：</strong>黑盒测试是在程序接口进行的测试，它只检查程序功能是否能按照规格说明书的规定正常使用，程序是否能适当地接收输入数据产生正确的输出信息，并且保持外部信息的完整性。</p>
<p>黑盒测试依赖于测试环境下应用的需求说明或功能描述。</p>
<p>第三方测试大多采用黑盒测试方法。</p>
<p><strong>静态黑盒</strong>测试产品说明书属于静态黑盒测试</p>
<p><strong>动态黑盒</strong>不深入代码细节的软件测试方法称为动态黑盒测试（常被称为行为测试）</p>
<h3 id="黑盒测试用例设计"><a href="#黑盒测试用例设计" class="headerlink" title="黑盒测试用例设计"></a>黑盒测试用例设计</h3><pre><code>等价类划分、边界值分析、错误猜测、判定表、因果图
</code></pre><h4 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h4><p>等价类是输入域的某个子集合，而所有的等价类的并集是整个输入域。在子集合中，各个输入数据对于揭露程序中的错误是等效的。</p>
<pre><code>完备性、无冗余性、等价性
例子在P49
</code></pre><h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4><p>边界值分析是等价划分的扩展，包括等价类+划分的边界值，边界值通常是等价类的界限。</p>
<blockquote>
<p>边界值分析与等价类划分的区别</p>
<ul>
<li>不是在等价类中选择一个元素作为代表，而是在挑选元素时使得等价类（EC）的边界受到测试。</li>
<li>不只关注输入条件，也注意输出条件</li>
</ul>
</blockquote>
<p>对于一个<strong>n变量</strong>的程序，边界值分析测试程序会产生<strong>4n+1</strong>个测试用例。</p>
<pre><code>健壮性测试、最坏情况测试、例子在P77
</code></pre><h4 id="错误猜测法"><a href="#错误猜测法" class="headerlink" title="错误猜测法"></a>错误猜测法</h4><p>错误猜测是基于经验和其他一些测试技术（如边界值测试）的</p>
<p>错误推测法的基本想法是：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例。</p>
<h4 id="判定表法"><a href="#判定表法" class="headerlink" title="判定表法"></a>判定表法</h4><p>P101</p>
<p>列出条件项和动作项，对不同的条件进行选择</p>
<h4 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h4><p>因果图是一种挑选高效测试用例以检查组合输入条件的系统方法</p>
<p>等价类划分方法和边界值分析法都是着重考虑输入条件，并没有考虑到输入情况的各种组合，也没考虑到各个输入情况之间的相互制约关系。</p>
<p>基本图形符号<br><img src="http://i.imgur.com/c22vOjT.jpg" alt=""></p>
<p>条件约束符号<br><img src="http://i.imgur.com/R8u4Qtj.jpg" alt=""></p>
<p>例子P129</p>
<hr>
<h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><p><strong>定义</strong>：白盒测试是知道产品内部工作过程，可通过测试来检测产品内部动作是否按照规格说明书的规定正常进行。</p>
<blockquote>
<p>黑盒测试与白盒测试区别：</p>
<p>黑盒测试：</p>
<ul>
<li>不涉及程序结构</li>
<li>用软件规格说明生成测试用例</li>
<li>某些代码段得不到测试</li>
<li>可适用于从单元测试到系统测试</li>
<li>需要用白盒测试加以补充</li>
</ul>
<p>白盒测试：</p>
<ul>
<li>考查程序逻辑结构</li>
<li>用程序结构信息生成测试用例</li>
<li>通常适用于单元测试和集成测试</li>
</ul>
</blockquote>
<h3 id="白盒测试用例设计"><a href="#白盒测试用例设计" class="headerlink" title="白盒测试用例设计"></a>白盒测试用例设计</h3><pre><code>单元测试、集成测试、系统测试、验收测试
</code></pre><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>单元测试是在模块源程序代码编写完成之后进行的测试。以把单元测试看成是从详细设计开始一直到系统构造完成贯穿于整个时期的一种活动。</p>
<p>定义：</p>
<blockquote>
<p>对结构化程序：单元测试就是对函数或子程序进行的测试<br>对面向对象程序：单元测试是对类或方法的测试</p>
</blockquote>
<p>目的：</p>
<ul>
<li>验证代码是与设计相符合的</li>
<li>跟踪需求和设计的实现</li>
<li>发现设计和需求中存在的缺陷</li>
<li>发现在编码过程中引入的错误</li>
</ul>
<p><strong>调试</strong>：调试的任务是进一步诊断和改正程序中潜在的错误。</p>
<p><img src="http://i.imgur.com/bE3mnD0.jpg" alt=""></p>
<p><strong>单元测试策略</strong></p>
<p><em>自顶向下策略</em>：从最顶层的单元开始，把顶层调用的单元用桩模块代替，对顶层模块做单元测试。对下一层单元进行测试时，使用上面已测试的单元做驱动模块，并为被测模块编写新的桩模块。<br>特点：为系统提供早期的集成途径，测试工作与编码工作同步进行，但是过程可能会越来越复杂</p>
<p><em>自底向上策略</em>：从最底层单元进行测试，使用驱动模块来代替调用它的上层单元。对上一层单元进行测试时，用已经被测试过的模块做桩模块，并为被测单元编写新的驱动模块。<br>特点：不需要单独设计桩模块；无需依赖结构设计，但不能和编码同步进行</p>
<p><em>孤立测试</em>：每个模块都单独测试，简单易操作，高覆盖率，无依赖性。但是无法早期集成，成本较高。</p>
<h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><p>集成测试的目标是根据实际情况对程序模块采用适当的集成测试策略组装起来，对系统的接口以及集成后的功能进行正确性检验的测试工作。</p>
<pre><code>传统软件集成层次：
模块内集成测试，子系统内集成测试，子系统间集成测试

对于面向对象集成层次：
类内集成测试，类间集成测试
</code></pre><p>集成测试环境因素：硬件环境、操作系统环境、数据库环境、网络环境、测试工具环境、其他环境</p>
<p><strong>集成测试策略</strong>：</p>
<p>一次性集成、自顶向下增量、自底向上增量、混合式增量（三明治）</p>
<p>自顶向下的集成方式可以采用深度优先策略和广度优先策略。</p>
<p>设计桩模块比设计驱动模块成本高。</p>
<h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><p>系统测试的目标在于通过与系统的需求规格说明进行比较，检查软件是否存在与系统规格不符合或与之矛盾的地方，以验证软件系统的功能和性能等满足规格说明所指定的要求。</p>
<p>测试设计人员应该主要根据需求规格说明来设计系统测试的测试用例。</p>
<h4 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h4><p>以黑盒测试为主，根据需要辅以白盒测试</p>
<h4 id="综合测试"><a href="#综合测试" class="headerlink" title="综合测试"></a>综合测试</h4><p>先静态后动态的组合方式：先进行静态结构分析、代码检查和静态质量度量，再进行覆盖率测试</p>
<p>在不同的测试阶段，测试的侧重点不同：在单元测试阶段，以代码检查、逻辑覆盖为主；在集成测试阶段，需要增加静态结构分析、静态质量度量；在系统测试阶段，应根据黑盒测试的结果，采取相应的白<br>盒测试。</p>
<h3 id="静态结构分析"><a href="#静态结构分析" class="headerlink" title="静态结构分析"></a>静态结构分析</h3><p>在静态结构分析中，测试者通过使用测试工具分析程序源代码的系统结构、数据结构、数据接口、内部控制逻辑等内部结构，生成函数调用关系图、模块控制流图、内部文件调用关系图、子程序表、宏和函数参数表等各类图形图表，可以清晰地标识整个软件系统的组成结构，使其便于阅读与理解，然后可以通过分析这些图表，检查软件有没有存在缺陷或错误。</p>
<h3 id="静态-amp-动态白盒测试"><a href="#静态-amp-动态白盒测试" class="headerlink" title="静态&amp;动态白盒测试"></a>静态&amp;动态白盒测试</h3><blockquote>
<p><strong>代码检查</strong>：</p>
<ul>
<li>确保代码编程标准被有效地执行</li>
<li>提高代码质量，减轻动态测试负担</li>
<li>代码可重复使用，降低项目风险与经费</li>
<li>增加程序的可理解性，降低维护成本</li>
</ul>
<p>方式：桌面检查（自查）、代码审查（审查小组）、走查</p>
</blockquote>
<p>动态白盒测试特点：</p>
<ul>
<li><p>必须生成测试数据来运行被测试程序，取得程序运行的真实情况、动态情况，进而进行分析</p>
</li>
<li><p>测试质量依赖于测试数据</p>
</li>
<li><p>生成测试数据、分析测试结果的工作量大，使开展测试工作费时、费力、费人</p>
</li>
<li><p>动态测试中涉及多方面工作，人员多、设备多、数据多，要求有较好的管理和工作规程</p>
</li>
</ul>
<pre><code>类别：功能确认与接口分析，性能与效率分析，内存分析，代码跟踪，逻辑覆盖率分析
</code></pre><h4 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h4><pre><code>类别：语句覆盖、判定覆盖、条件覆盖、条件-判定覆盖、条件-组合覆盖、路径覆盖
</code></pre><p><strong>解题过程</strong>：</p>
<ol>
<li>画出程序流程图</li>
<li>写出所有的判定、条件、路径，并标号</li>
<li>根据覆盖要求写出测试用例，并分析出条件、路径的覆盖情况</li>
</ol>
<h5 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a>语句覆盖</h5><p>每一条可执行语句至少执行一次</p>
<h5 id="判定覆盖"><a href="#判定覆盖" class="headerlink" title="判定覆盖"></a>判定覆盖</h5><p>程序中每个判定至少都获得一次“真”值和“假”值，也称分支覆盖。（忽略了Bool型表达式内部的Bool取值。）</p>
<h5 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h5><p>每个判定中的每个条件的可能值至少满足一次。完全的条件覆盖并不能保证完全的判定覆盖</p>
<h5 id="条件-判定覆盖"><a href="#条件-判定覆盖" class="headerlink" title="条件-判定覆盖"></a>条件-判定覆盖</h5><p>判定中每个条件的所有可能（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次</p>
<h5 id="条件-组合覆盖"><a href="#条件-组合覆盖" class="headerlink" title="条件-组合覆盖"></a>条件-组合覆盖</h5><p>判定条件中条件的每一种可能组合至少出现一次；判定语句中有N个逻辑条件，每个逻辑条件有两种可能取值，则共有2N种可能组合</p>
<ul>
<li>条件组合覆盖〉判定覆盖〉语句覆盖</li>
<li>条件组合覆盖〉条件覆盖</li>
<li>条件覆盖不一定包含判定覆盖、语句覆盖</li>
<li>判定覆盖不一定包含条件覆盖</li>
<li>路径覆盖〉判定覆盖〉语句覆盖</li>
</ul>
<h5 id="控制流图"><a href="#控制流图" class="headerlink" title="控制流图"></a>控制流图</h5><p><img src="http://i.imgur.com/dqPyDLG.jpg" alt=""></p>
<p>复杂度=区域数目 | 边界数目-节点数目+2 | 判定节点数目+1</p>
<h5 id="基本路径测试"><a href="#基本路径测试" class="headerlink" title="基本路径测试"></a>基本路径测试</h5><p>基本路径测试方法把覆盖的路径数压缩到一定限度内，程序中的循环体最多只执行一次</p>
<blockquote>
<p>步骤</p>
<ul>
<li>以详细设计或源代码作为基础，导出程序的控制流图</li>
<li>计算得到的控制流图G的环路复杂性V（G）</li>
<li>确定线性无关的路径的基本集</li>
<li>生成测试用例，确保基本路径集中每条路径的执行</li>
</ul>
</blockquote>
<h2 id="面向对象测试"><a href="#面向对象测试" class="headerlink" title="面向对象测试"></a>面向对象测试</h2><p>测试步骤：</p>
<ul>
<li>面向对象分析的测试</li>
<li>面向对象设计的测试</li>
<li>面向对象编程的测试</li>
<li>面向对象单元测试</li>
<li>面向对象集成测试</li>
<li>面向对象确认和系统测试</li>
</ul>
<h3 id="基于场景的测试"><a href="#基于场景的测试" class="headerlink" title="基于场景的测试"></a>基于场景的测试</h3><p>基于场景的测试主要关注用户需要做什么，而不是产品能做什么，即从用户任务（使用用例）中找出用户要做什么及如何去执行。</p>
<p>P69</p>
<h3 id="类的随机测试"><a href="#类的随机测试" class="headerlink" title="类的随机测试"></a>类的随机测试</h3><p>如果一个类有多个操作（功能），这些操作（功能）序列有多种排列。而这种不变化的操作序列可随机产生，用这种可能随机排列的序列来检查不同类实例的生存史，就叫随机测试。</p>
<h3 id="类层次的分割测试"><a href="#类层次的分割测试" class="headerlink" title="类层次的分割测试"></a>类层次的分割测试</h3><p>很像传统软件测试中的等价类划分测试。</p>
<ul>
<li>基于状态的分割</li>
<li>基于属性的分割</li>
<li>基于类型的分割</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Fade away游戏试玩视频]]></title>
      <url>http://yoursite.com/2016/05/19/Fade%20away%20test/</url>
      <content type="html"><![CDATA[<h2 id="Fade-Away"><a href="#Fade-Away" class="headerlink" title="Fade Away"></a>Fade Away</h2><p>此游戏是BIT《游戏设计概论》课程的实践项目，基于UNITY 3D开发，项目历时不足两月。</p>
<p>水平有限，还请多多批评O(∩_∩)O</p>
<pre><code>评论模块还在施工中/(ㄒoㄒ)/~~可以在微博中call我
</code></pre><hr>
<iframe height="768" width="1280" src="http://cache.tv.qq.com/qqplayerout.swf?vid=c03084s0idi" frameborder="0" allowfullscreen><br></iframe>]]></content>
    </entry>
    
  
  
</search>
